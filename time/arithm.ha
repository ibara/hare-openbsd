// License: MPL-2.0
// (c) 2022 Byron Torres <b@torresjrjr.com>
// (c) 2021 Drew DeVault <sir@cmpwn.com>

// Adds a [[duration]] to an [[instant]], returning an instant further in the
// future (given a positive duration), or further in the past (given a negative
// duration).
export fn add(a: instant, d: duration) instant = {
	if (d == 0) {
		return a;
	} else if (d > 0) {
		return instant {
			sec = a.sec + (a.nsec + d) / SECOND,
			nsec = (a.nsec + d) % SECOND,
		};
	} else {
		return instant {
			sec = a.sec + (a.nsec + d - SECOND + NANOSECOND) / SECOND,
			nsec = (a.nsec + (d % SECOND) + SECOND) % SECOND,
		};
	};
};

// Returns the [[duration]] from [[instant]] "a" to [[instant]] "b".
export fn diff(a: instant, b: instant) duration = {
	return ((b.sec - a.sec) * SECOND) + (b.nsec - a.nsec);
};

// Returns -1 if a precedes b, 0 if a and b are simultaneous, or +1 if b
// precedes a.
export fn compare(a: instant, b: instant) i8 = {
	return if (a.sec < b.sec) -1
	else if (a.sec > b.sec) 1
	else if (a.nsec < b.nsec) -1
	else if (a.nsec > b.nsec) 1
	else 0;
};

@test fn add() void = {
	const cases = [
	//	instant a        duration d    instant b
		( 0, 000000000,  -2000000001,  -3, 999999999),
		( 0, 000000000,  -2000000000,  -2, 000000000),
		( 0, 000000000,  -1999999999,  -2, 000000001),
		( 0, 000000000,  -1000000001,  -2, 999999999),
		( 0, 000000000,  -1000000000,  -1, 000000000),
		( 0, 000000000,  -0999999999,  -1, 000000001),
		( 0, 000000000,  -0000000001,  -1, 999999999),
		( 0, 000000000,   0000000000,   0, 000000000),
		( 0, 000000000,   0000000001,   0, 000000001),
		( 0, 000000000,   0999999999,   0, 999999999),
		( 0, 000000000,   1000000000,   1, 000000000),
		( 0, 000000000,   1000000001,   1, 000000001),
		( 0, 000000000,   1999999999,   1, 999999999),
		( 0, 000000000,   2000000000,   2, 000000000),
		( 0, 000000000,   2000000001,   2, 000000001),

		( 0, 000000001,  -2000000001,  -2, 000000000),
		( 0, 000000001,  -2000000000,  -2, 000000001),
		( 0, 000000001,  -1999999999,  -2, 000000002),
		( 0, 000000001,  -1000000001,  -1, 000000000),
		( 0, 000000001,  -1000000000,  -1, 000000001),
		( 0, 000000001,  -0999999999,  -1, 000000002),
		( 0, 000000001,  -0000000001,   0, 000000000),
		( 0, 000000001,   0000000000,   0, 000000001),
		( 0, 000000001,   0000000001,   0, 000000002),
		( 0, 000000001,   0999999999,   1, 000000000),
		( 0, 000000001,   1000000000,   1, 000000001),
		( 0, 000000001,   1000000001,   1, 000000002),
		( 0, 000000001,   1999999999,   2, 000000000),
		( 0, 000000001,   2000000000,   2, 000000001),
		( 0, 000000001,   2000000001,   2, 000000002),

		(-1, 999999999,  -2000000001,  -3, 999999998),
		(-1, 999999999,  -2000000000,  -3, 999999999),
		(-1, 999999999,  -1999999999,  -2, 000000000),
		(-1, 999999999,  -1000000001,  -2, 999999998),
		(-1, 999999999,  -1000000000,  -2, 999999999),
		(-1, 999999999,  -0999999999,  -1, 000000000),
		(-1, 999999999,  -0000000001,  -1, 999999998),
		(-1, 999999999,   0000000000,  -1, 999999999),
		(-1, 999999999,   0000000001,   0, 000000000),
		(-1, 999999999,   0999999999,   0, 999999998),
		(-1, 999999999,   1000000000,   0, 999999999),
		(-1, 999999999,   1000000001,   1, 000000000),
		(-1, 999999999,   1999999999,   1, 999999998),
		(-1, 999999999,   2000000000,   1, 999999999),
		(-1, 999999999,   2000000001,   2, 000000000),

		( 0, 999999999,  -2000000001,  -2, 999999998),
		( 0, 999999999,  -2000000000,  -2, 999999999),
		( 0, 999999999,  -1999999999,  -1, 000000000),
		( 0, 999999999,  -1000000001,  -1, 999999998),
		( 0, 999999999,  -1000000000,  -1, 999999999),
		( 0, 999999999,  -0999999999,   0, 000000000),
		( 0, 999999999,  -0000000001,   0, 999999998),
		( 0, 999999999,   0000000000,   0, 999999999),
		( 0, 999999999,   0000000001,   1, 000000000),
		( 0, 999999999,   0999999999,   1, 999999998),
		( 0, 999999999,   1000000000,   1, 999999999),
		( 0, 999999999,   1000000001,   2, 000000000),
		( 0, 999999999,   1999999999,   2, 999999998),
		( 0, 999999999,   2000000000,   2, 999999999),
		( 0, 999999999,   2000000001,   3, 000000000),
	];

	for (let i = 0z; i < len(cases); i += 1) {
		const C = cases[i];
		const a = instant { sec = C.0, nsec = C.1 };
		const d = C.2;
		const b = instant { sec = C.3, nsec = C.4 };
		const B = add(a, d);
		assert(B.sec == b.sec, "time::add() .sec error");
		assert(B.nsec == b.nsec, "time::add() .nsec error");
	};
};

@test fn compare() void = {
	let a = now(clock::MONOTONIC);
	sleep(1 * MILLISECOND);
	let b = now(clock::MONOTONIC);
	assert(compare(a, b) < 0);
	assert(compare(b, a) > 0);
	assert(compare(a, a) == 0);
};
